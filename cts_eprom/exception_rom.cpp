#include <iostream>
#include <format>
#include <array>
#include "exception_rom.h"

const std::vector<uint8_t> signature = {
    0x80, 0x48, 0x28, 0x58, 0x85
};

const std::vector<uint8_t> jumps = {
    0xe0, 0x35, 0xe0, 0x31
};

struct Routine {
    const uint16_t address;
    const std::vector<uint8_t> code;
    const std::vector<uint16_t> fixups;

    Routine(uint16_t address, std::initializer_list<uint8_t> code,
        std::initializer_list<uint16_t> fixups) :
            address(address), code(code), fixups(fixups) {}
};

const Routine new_parameter_init_routine{0x023,
    { 0x1e, 0x1f, 0x20, 0x21, 0x28, 0x29, 0x24, 0x25,
      0x22, 0x23, 0x2a, 0x2b, 0x26, 0x27, 0x2c, 0x2d,
  	  0x2e, 0x2f, 0x32, 0x33, 0x34, 0x35, 0x36, 0xe0,
      0x65, 0x78, 0x02, 0x31, 0x8e, 0xf1, 0x43, 0xc5,
	  0xaa, 0x00, 0x09, 0x2d, 0xff, 0xe2, 0x1e, 0xb8,
      0xaa, 0x00, 0x23, 0xd5, 0x12, 0xd0, 0x13, 0xb9,
	  0x9b, 0x13, 0xc3, 0xaa, 0x00, 0x09, 0x2d, 0xff,
      0xe2, 0x0b, 0xb8, 0xaa, 0x00, 0x23, 0xd5, 0x12,
	  0xd0, 0x13, 0xb9, 0x9b, 0x13, 0x5d, 0x16, 0xe6,
      0xe9, 0xc3, 0xaa, 0x00, 0x09, 0x2d, 0xff, 0xe2,
	  0x14, 0xa2, 0x40, 0x11, 0x82, 0x11, 0xa2, 0x15,
      0x11, 0xc3, 0xaa, 0x00, 0x09, 0x82, 0x15, 0xc3,
	  0xaa, 0x00, 0x09, 0x82, 0x14, 0x98, 0x29, 0x03,
      0x98, 0x2b, 0x07, 0x22, 0x20, 0x9b, 0x03, 0x8e,
	  0xf7, 0x2b, 0x9b, 0x03, 0x05, 0x98, 0x07, 0x09,
      0x98, 0x03, 0x19, 0x8c, 0xf1, 0x00, 0xe0, 0x36 },
    { 0x044, 0x04c, 0x057, 0x05f, 0x06e, 0x07e, 0x084 }
};

Routine exception_word_routine{0x0d9,
	{ 0xd8, 0x02, 0xd8, 0x03, 0x98, 0x03, 0x11, 0x8e,
      0xf7, 0x4b, 0x8e, 0xf7, 0x0f, 0x77, 0x01, 0x0a,
	  0x05, 0x74, 0x80, 0x0b, 0xe0, 0x03, 0x73, 0x7f,
      0x0b, 0x8e, 0xf3, 0xaf, 0x76, 0x20, 0x0a, 0x0e,
	  0x52, 0x34, 0xaa, 0x50, 0xa3, 0xd0, 0x14, 0xaa,
      0x50, 0xa4, 0xd0, 0x15, 0xe0, 0x0f, 0xc5, 0x2a,
	  0x41, 0x2c, 0x02, 0xaa, 0x50, 0xa3, 0xd0, 0x14,
      0xaa, 0x50, 0xa4, 0xd0, 0x15, 0x52, 0x01, 0x8e,
	  0xf4, 0x88, 0x8e, 0xf4, 0xc2, 0x76, 0x10, 0x0a,
      0x4d, 0x2d, 0xff, 0xe2, 0x60, 0x98, 0x11, 0x1d,
	  0x73, 0xbf, 0x0a, 0x8e, 0xf5, 0x64, 0x76, 0x10,
      0x0a, 0x3c, 0x8e, 0xf4, 0x7e, 0x74, 0x40, 0x0a,
	  0x8e, 0xf5, 0x64, 0x76, 0x10, 0x0a, 0x42, 0x48,
      0x37, 0x34, 0x79, 0x00, 0x33, 0xd5, 0x37, 0x73,
	  0xfd, 0x0b, 0x52, 0x02, 0x8e, 0xf4, 0x88, 0x8e,
      0xf4, 0x9e, 0x98, 0x0f, 0x03, 0x98, 0x03, 0x11,
	  0x8e, 0xf7, 0x4b, 0x77, 0x80, 0x0b, 0x0a, 0xdb,
      0x39, 0x8e, 0xf3, 0x47, 0xc9, 0xc9, 0x8c, 0xf1,
	  0x36, 0xc9, 0xc9, 0x8c, 0xf3, 0xf4, 0xd3, 0x15,
      0xe7, 0x02, 0xd3, 0x14, 0x52, 0x02, 0x8e, 0xf4,
	  0x88, 0x72, 0x01, 0x37, 0x73, 0xfd, 0x0b, 0xe0,
      0x99, 0x52, 0x03, 0xe0, 0xf1, 0xd9, 0x03, 0xd9,
	  0x02, 0xd5, 0x37, 0x73, 0xfd, 0x0b, 0x8c, 0xf3,
      0xee, 0xff },
    { 0x0fc, 0x101, 0x10d, 0x112 }
};

ExceptionROM::ExceptionROM(uint16_t address, size_t rom_size) :
    rom_(rom_size, 0xff), address_(address) {
}

ExceptionROM::ExceptionROM(uint16_t address, std::vector<uint8_t>&& content) :
    rom_{std::move(content)}, address_(address) {
}

void ExceptionROM::encode(const std::vector<CtsException>& exceptions)
{
    std::copy(signature.begin(), signature.end(), rom_.begin());

    std::copy(jumps.begin(), jumps.end(), rom_.begin() + signature.size());

    // The new parameters are all left at their default values (0xff) for now.

    std::copy(new_parameter_init_routine.code.begin(),
              new_parameter_init_routine.code.end(),
              rom_.begin() + new_parameter_init_routine.address);

    for (auto& fixup : new_parameter_init_routine.fixups) {
        rom_[fixup] = (address_ >> 8) & 0xff;
    }

    std::copy(exception_word_routine.code.begin(),
              exception_word_routine.code.end(),
              rom_.begin() + exception_word_routine.address);

    for (auto& fixup : exception_word_routine.fixups) {
        rom_[fixup] = (address_ >> 8) & 0xff;
    }

    std::array<std::vector<CtsException>, 27> exception_table{};

    for (auto& exception : exceptions) {
        int index = exception.tag().to_index();
        exception_table[index].push_back(exception);
    }

    auto index_it = rom_.begin() + 0x0a3;
    auto table_it = rom_.begin() + exception_word_routine.address +
        exception_word_routine.code.size();

    auto address = address_of(table_it);

    for (auto& entries : exception_table) {
        *index_it++ = (address >> 8) & 0xff;
        *index_it++ = address & 0xff;

        for (auto& entry : entries) {
            auto encoded = entry.to_bytes();
            table_it = std::copy(encoded.begin(), encoded.end(), table_it);
            address += encoded.size();
        }

        *table_it++ = 0xff;
        address++;
    }
}

const std::vector<CtsException> ExceptionROM::decode()
{
    std::vector<CtsException> exceptions;
    auto index_it = rom_.begin() + 0xa3;
    char symbol = 'A';

    for (int i = 0; i < 27; i++) {
        uint16_t offset = *index_it++;
        offset = (offset << 8) | *index_it++;
        offset -= address_;

        auto begin = rom_.begin() + offset;

        while (*begin != 0xff) {
            auto end = std::find_if(begin, rom_.end(),
                [](uint8_t element) {
                    return (element & 0x80) != 0;
                });

            if (end != rom_.end()) {
                end = std::find_if(end + 1, rom_.end(),
                [](uint8_t element) {
                    return (element & 0x80) != 0;
                });
            }

            if (end != rom_.end()) {
                end = end + 1;
            }

            std::vector<uint8_t> encoded{begin, end};

            if (i < 26) {
                exceptions.push_back(CtsException(CtsTag{symbol}, encoded));
            }
            else {
                auto it = std::find_if(begin, end,
                    [](uint8_t element) {
                        return (element & 0x40) != 0;
                    });
                char symbol = *it & ~(0x40 | 0x80);
                exceptions.push_back(CtsException(CtsTag{symbol}, encoded));
            }

            begin = end;
        }

        symbol++;
    }

    return exceptions;
}

template<typename TIterator>
uint16_t ExceptionROM::address_of(TIterator it)
{
    return static_cast<uint16_t>(std::distance(rom_.begin(), it) + address_);
}
